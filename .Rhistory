geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
q <- quantile(never_met[,i], probs = c(0.025,0.975))
ci <- data.frame(quantile=names(q), values = unname(q))
png(filename = paste(names[i], ".png", sep = ""), width = 3, height = 4, units = "in", res = 200)
ggplot() +
geom_histogram(data = never_met, aes(x = never_met[,i])) +
geom_point(data = familiar, aes(x = familiar[,i], y = 0), color = "red", size = 5) +
geom_vline(data = ci, aes(xintercept = values, color = "red"), show.legend = F) +
xlab(paste(colnames(never_met)[i], colnames(familiar)[i], sep = "-"))
dev.off()
i <- i+1
# load packages
library(devtools)
library(STRAND)
install.packages("STRAND")
install.packages("strand")
library(STRAND)
uninstall("strand")
library(strand)
remove.packages("strand")
R.version
R.version
library(devtools)
install_github('ctross/STRAND@phosphorescent_desert_buttons')
install.packages(cmdstanr)
install.packages("cmdstanr")
install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))
library(devtools)
install_github('ctross/STRAND@phosphorescent_desert_buttons')
library(cmdstanr)
install_github('ctross/STRAND@phosphorescent_desert_buttons')
check_cmdstan_toolchain()
install_cmdstan(cores = 2)
install_github('ctross/STRAND@phosphorescent_desert_buttons')
library(remotes)
install_github('ctross/STRAND@phosphorescent_desert_buttons')
library(devtools)
# load packages
library(devtools)
GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
library(cmdstanr)
library(devtools)
install_github('ctross/STRAND@phosphorescent_desert_buttons')
gitcreds_set()
library(usethis)
git_sitrep()
create_github_token()
gitcreds::gitcreds_set()
install_github('ctross/STRAND@phosphorescent_desert_buttons')
# load packages
library(devtools)
library(STRAND)
library(tidyverse)
library(igraph)
library(diffr)
install.packages("diffr")
library(diffr)
diffr("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs/number_of_calls_01.R","/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs/number_of_calls_02.R")
# analysis for 2024 paired recordings
# question 1: do different bats call different amounts? does calling rate depend on recipient?
# use Bayesian social relations model, strand package
# actor, receiver, and interaction automatically included
# response variable = call count
# predictor = Haley's grooming OR food-sharing? maybe just the data from before my data?
# results: effects of actor's tendency to call, receiver's tendency to receive, correlation at dyadic level between caller calling and receiver calling (do the bats I call to more call to me more, controlling for overall calling and receiving rate), correlation at group level (if I call more to the group, does the group call more to me?) and THEN finally will tell us whether bats are calling more depending on predictor variable
# how to make use of added power from 3 replicate matrices? for now, take average, but keep thinking about this
# Julia Vrtilek
# Adapted from Haley Gmutza, May 2025
# load packages
library(STRAND)
library(tidyverse)
library(igraph)
setwd("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs")
# load and wrangle vocal data ----
batcalls <- readRDS("vocal_data_2024-pairs.RDS") %>%
group_by(caller, receiver) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", receiver = "yikes", n.calls = 0) %>% # quark never called. this row makes names appear alphabetically
arrange(caller)
netcalls <- graph_from_data_frame(batcalls)
mcalls <- as_adjacency_matrix(netcalls, attr= 'n.calls', sparse=F)
nets = list(call = mcalls)
bats.used <- rownames(mcalls)
# load and wrangle social data ----
# already trimmed bat donations list
donations <- read.csv('OSU_2024_social_data.csv')
donations$Actor <- tolower(donations$Actor)
donations$Receiver <- tolower(donations$Receiver)
bat.donations <- donations %>%
filter(Actor %in% bats.used) %>%
filter(Receiver %in% bats.used)
# make foodsharing matrix
rates <-
bat.donations %>%
filter(Behavior == "Mouthlicking") %>%
mutate(edge= paste(Actor, Receiver, sep="_")) %>%
group_by(edge) %>%
summarize(rate= sum(rate, na.rm=T)) %>%
filter(rate>=0) %>%
separate(edge, into=c('Actor', 'Receiver'))
net <- graph_from_data_frame(rates)
m <- as_adjacency_matrix(net, attr= 'rate', sparse=F)
# # make grooming matrix
# ratesg <-
#   bat.donations %>%
#   filter(Behavior == "Grooming") %>%
#   mutate(edge= paste(Actor, Receiver, sep="_")) %>%
#   group_by(edge) %>%
#   summarize(rate= sum(rate, na.rm=T)) %>%
#   filter(rate>=0) %>%
#   separate(edge, into=c('Actor', 'Receiver'))
#
# netg <- graph_from_data_frame(ratesg)
# mg <- as_adjacency_matrix(netg, attr= 'rate', sparse=F)
# individual variable - age
chars <- read.csv('campus_bat_chars.csv', stringsAsFactors = F)
chars$Bat.name <- tolower(chars$Bat.name)
batchars <- chars %>%
filter(Bat.name %in% bats.used) %>%
select(Age)
rownames(batchars) <- bats.used
# dyadic variables - kinship, foodsharing
distmat <- read.delim('Desmodus_DistanceMatrix.txt',row.names = 1)
distmat <- data.matrix(distmat)
dyad = list(#Kinship = distmat,
Lick = m)
# Make the STRAND data structure ----
dat = make_strand_data(
outcome = nets,
individual_covariates = batchars,
dyadic_covariates = dyad,
outcome_mode = "poisson",
link_mode = "log",
check_standardization = F) # I don't see why we would standardize age??? but maybe we should
View(batcalls)
batcalls <- readRDS("vocal_data_2024-pairs.RDS")
View(batcalls)
str(batcalls)
# load and wrangle vocal data ----
raw <- readRDS("vocal_data_2024-pairs.RDS") %>%
mutate(date = as.Date(date))
# analysis for 2024 paired recordings
# question 1: do different bats call different amounts? does calling rate depend on recipient?
# use Bayesian social relations model, strand package
# actor, receiver, and interaction automatically included
# response variable = call count
# predictor = Haley's grooming OR food-sharing? maybe just the data from before my data?
# results: effects of actor's tendency to call, receiver's tendency to receive, correlation at dyadic level between caller calling and receiver calling (do the bats I call to more call to me more, controlling for overall calling and receiving rate), correlation at group level (if I call more to the group, does the group call more to me?) and THEN finally will tell us whether bats are calling more depending on predictor variable
# how to make use of added power from 3 replicate matrices? for now, take average, but keep thinking about this
# Julia Vrtilek
# Adapted from Haley Gmutza, May 2025
# load packages
library(STRAND)
library(tidyverse)
library(igraph)
setwd("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs")
# load and wrangle vocal data ----
raw <- readRDS("vocal_data_2024-pairs.RDS") %>%
mutate(date = as.Date(date))
str(raw)
# load and wrangle vocal data ----
raw <- readRDS("vocal_data_2024-pairs.RDS") %>%
mutate(date = as.Date(date)) %>%
mutate(session = case_when(date < "2024-07-22" ~ "1",
date > "2024-07-21" & date < "2024-07-29" ~ "2",
date > "2024-07-28" ~ "3"))
View(raw)
batcalls <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", receiver = "yikes", n.calls = 0) %>% # quark never called. this row makes names appear alphabetically
arrange(caller)
View(batcalls)
View(batcalls)
View(raw)
netcalls <- graph_from_data_frame(batcalls)
mcalls <- as_adjacency_matrix(netcalls, attr= 'n.calls', sparse=F)
nets = list(call = mcalls)
bats.used <- rownames(mcalls)
View(nets)
View(batcalls)
batcalls <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", receiver = "yikes", n.calls = 0) %>% # quark never called. this row makes names appear alphabetically
netcalls <- graph_from_data_frame(batcalls)
batcalls <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", receiver = "yikes", n.calls = 0) # quark never called. this row makes names appear alphabetically
View(batcalls)
# analysis for 2024 paired recordings
# question 1: do different bats call different amounts? does calling rate depend on recipient?
# use Bayesian social relations model, strand package
# actor, receiver, and interaction automatically included
# response variable = call count
# predictor = Haley's grooming OR food-sharing? maybe just the data from before my data?
# results: effects of actor's tendency to call, receiver's tendency to receive, correlation at dyadic level between caller calling and receiver calling (do the bats I call to more call to me more, controlling for overall calling and receiving rate), correlation at group level (if I call more to the group, does the group call more to me?) and THEN finally will tell us whether bats are calling more depending on predictor variable
# how to make use of added power from 3 replicate matrices? for now, take average, but keep thinking about this
# Julia Vrtilek
# Adapted from Haley Gmutza, May 2025
# load packages
library(STRAND)
library(tidyverse)
library(igraph)
setwd("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs")
# load and wrangle vocal data ----
raw <- readRDS("vocal_data_2024-pairs.RDS") %>%
mutate(date = as.Date(date)) %>%
mutate(session = case_when(date < "2024-07-22" ~ "1",
date > "2024-07-21" & date < "2024-07-29" ~ "2",
date > "2024-07-28" ~ "3"))
batcalls <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", # quark never called; adding this row makes names appear alphabetically
receiver = "yikes", session = 1, n.calls = 0)
# analysis for 2024 paired recordings
# question 1: do different bats call different amounts? does calling rate depend on recipient?
# use Bayesian social relations model, strand package
# actor, receiver, and interaction automatically included
# response variable = call count
# predictor = Haley's grooming OR food-sharing? maybe just the data from before my data?
# results: effects of actor's tendency to call, receiver's tendency to receive, correlation at dyadic level between caller calling and receiver calling (do the bats I call to more call to me more, controlling for overall calling and receiving rate), correlation at group level (if I call more to the group, does the group call more to me?) and THEN finally will tell us whether bats are calling more depending on predictor variable
# how to make use of added power from 3 replicate matrices? for now, take average, but keep thinking about this
# Julia Vrtilek
# Adapted from Haley Gmutza, May 2025
# load packages
library(STRAND)
library(tidyverse)
library(igraph)
setwd("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs")
# load and wrangle vocal data ----
raw <- readRDS("vocal_data_2024-pairs.RDS") %>%
mutate(date = as.Date(date)) %>%
mutate(session = case_when(date < "2024-07-22" ~ "1",
date > "2024-07-21" & date < "2024-07-29" ~ "2",
date > "2024-07-28" ~ "3"))
batcalls <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", # quark never called; adding this row makes names appear alphabetically
receiver = "yikes", session = "1", n.calls = 0)
View(batcalls)
netcalls <- graph_from_data_frame(batcalls)
View(netcalls)
mcalls <- as_adjacency_matrix(netcalls, attr= 'n.calls', sparse=F)
nets = list(call = mcalls)
View(nets)
nets
View(batcalls)
batcalls <- raw %>%
group_by(caller, receiver) %>%
summarize(n.calls = n()) %>%
ungroup() #%>%
View(batcalls)
batcalls_session <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", # quark never called; adding this row makes names appear alphabetically
receiver = "yikes", session = "1", n.calls = 0)
# analysis for 2024 paired recordings
# question 1: do different bats call different amounts? does calling rate depend on recipient?
# use Bayesian social relations model, strand package
# actor, receiver, and interaction automatically included
# response variable = call count
# predictor = Haley's grooming OR food-sharing? maybe just the data from before my data?
# results: effects of actor's tendency to call, receiver's tendency to receive, correlation at dyadic level between caller calling and receiver calling (do the bats I call to more call to me more, controlling for overall calling and receiving rate), correlation at group level (if I call more to the group, does the group call more to me?) and THEN finally will tell us whether bats are calling more depending on predictor variable
# how to make use of added power from 3 replicate matrices? for now, take average, but keep thinking about this
# Julia Vrtilek
# Adapted from Haley Gmutza, May 2025
# load packages
library(STRAND)
library(tidyverse)
library(igraph)
setwd("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/pairs")
# load and wrangle vocal data ----
raw <- readRDS("vocal_data_2024-pairs.RDS") %>%
mutate(date = as.Date(date)) %>%
mutate(session = case_when(date < "2024-07-22" ~ "1",
date > "2024-07-21" & date < "2024-07-29" ~ "2",
date > "2024-07-28" ~ "3"))
batcalls_session <- raw %>%
group_by(caller, receiver, session) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", # quark never called; adding this row makes names appear alphabetically
receiver = "yikes", session = "1", n.calls = 0)
batcalls <- raw %>%
group_by(caller, receiver) %>%
summarize(n.calls = n()) %>%
ungroup() %>%
add_row(caller = "quark", # quark never called; adding this row makes names appear alphabetically
receiver = "yikes", n.calls = 0)
View(batcalls)
View(batcalls_session)
# clear workspace
rm(list=ls())
# set working directory
setwd("/Users/jkvrtilek/Desktop/OSU/PhD/GitHub/call-convergence-2025")
# load packages
library(tidyverse)
